# Backend Overview.
Basically `backend` is just a reminder of what to do when a web page needs to be hosted, user authenticated, AWS resources interfaced with, etc. Apart from obvious, minimization of repetition of the same code, the intention is to keep this "chapter" to document some design pattern related to serverless development using AWS CDK.  


## Key Functionalities (AI generated)
- **Certificate Generation**: Handles the creation and signing of digital certificates.
- **User Management**: Manages user registration, authentication, and authorization.
- **API Gateway**: Acts as a single entry point for all client requests and routes them to the appropriate services.
- **Logging and Monitoring**: Implements logging and monitoring to track the performance and health of the services.


### Here's `backend` structure with a brief description of some nested folders:

```
.vscode/                  # Contains Visual Studio Code specific settings
cdk.out/                  # Output directory for CDK synth and deploy
src/                      # Contains the source code of the project
  infra/                  # Infrastructure related code
    constructs/           # Contains AWS CDK constructs
    services/             # Contains AWS lambda handler and their modules 
    stacks/               # Contains CDK stack definitions
    utils/                # Contains utility functions
temp/                     # Temporary files
```

## Authentication Sequence.  

1.  `/okta/login` - When GET request comes in, it triggers CloudFront behavior that launches `oktaLoginLambda`. This function constructs Okta hosted OIDC login URL and then sends it back in `<meta http-equiv="Refresh" content="0; ${authorizeUrl}"/>` frame with code **302 Redirect**. Once the browser receives this lambda response it'll follow the custom Okta Login link (`${authorizeUrl}`, the #2 below) as if the end-user clicked on it.

2.  `okta.com/oauth2/v1/authorize?client_id` - Okta authorization returns its hosted login prompt. After successful login it calls the predefined (in your Okta app auth profile) callback URL, which is the next #3.

3.  `/okta/callback` - This behavior is triggered by GET request. In the response body (from the above step) Okta has sent us authorization `code` that this `oktaCallbackLambda` will attempt to exchange for Okta `id_token` and `access_token`.
    - It sends POST request to `okta.com/oauth2/v1/token`.
    - Redirects to the next in chain `/okta/authorize` while storing `id_token` and `access_token` values in **HttpOnly** cookies.
    - In parallel with the above POST, the lambda fetches your Okta app JWKS and stores it as `okta_jwks` cookie to be reused later.
    - The above POST has been reworked and now runs in the browser. See below `oktaCallbackLambda` for details.
      - Regardless, even from the browser, it should redirect to step #4.

4.  `/okta/authorize` - Triggers `oktaAuthorizeLambda` which does the following:
    - Verifies id and access tokens locally using obtained in the previous step JWKS.
    - Creates the CloudFront signed cookies: `CloudFront-Key-Pair-Id`, `CloudFront-Signature` and `CloudFront-Policy`.
    - Creates an app own JWT `Token`. It will only be needed if the app is going to publish/use some sort of API interface.
    - Finally, since all the CloudFront authentication cookie requirements are now satisfied, the lambda returns **302 Redirect** pointing to the main app url `/`.

5. From here on the **frontend** portion of the app takes over.

## Other CloudFront Lambda Behaviors.

  - `/logout` - Triggers `logoutLambda`. This lambda deletes authentication cookies effectively forcing you to login again.
  - `/aws/credentials` - Triggers `awsCredentialsLambda`. This lambda is used by **frontend** to obtain temporary AWS credentials.


#
# Features.

## Common Lambda Props.

  Common props are parsed from the props files: `cloudfrontKeys.json`, `oktaProps.json` and `stackOutputs.json` inside the stack constructs (i.e. `src/infra/constructs/oktaLoginLambda.ts`) and delivered to Lambdas as environment variables.

## Redirects.

  Communication between `frontend` and `backend` is chained via redirects. i.e. oktaLoginLambda composes the Okta login/auth URL and then redirects to it.
  - Two types of redirects are used in this project.
  - `<meta http-equiv="Refresh" content="0; ${redirectUrl}"/>` - inside \<html\>\<head\>\<\/head\>.
  - `window.location.replace("${redirectUrl}")` - in the JavaScript code.

## Flattening.
  `stackOutputs.json` is generated by the `cdk deploy` process and depending on the **Stack** structure may have a certain nested hierarchy where each stack name is a key of the object. Those names have no particular relevance other than separating name spaces. So in order to not to track those object keys after each parse `stackOutputs.json` needs to be flattened.
  ```
  import {flattenObject} from '../../../../utils/src/flattenObject'

  const stackOutputs = JSON.parse(readFileSync(path.join(__dirname, '..', '..', '..', './stackOutputs.json'), 'utf-8'))
  const { 
    appDomain,
  } = flattenObject(stackOutputs)
  ```

## Okta Claims to AWS Role Map.
  AWS construct `OktaOidcFederation` creates an AWS Role based on claims that Okta `id_token` must have. Conditions are built into the `Role` and only when they match, the `Role` will be assigned to the temporary Web user. The assignment takes place during `awsCredentialsLambda` execution.

  In the below example:
  - The **StringEquals** condition asserts that the audience (aud) claim should match the Okta app client id, and that the subject (sub) claim matches a specific service account.
  - The **StringLike** condition asserts that the group claim starts with "developers".

  ```
    {
      StringEquals: {
        'dev-123456789.okta.com:aud': '0ktaCli3nt!d',
        'dev-123456789.okta.com:sub': 'u3yrgwu67',
      },
      StringLike: {
        'dev-123456789.okta.com:group': 'developers*'
      }
    }
  ```
  #### From AWS `node_modules/@aws-sdk/client-sts/dist-types/models/models_0.d.ts` regarding the *aud* claim:

  <p>Additional considerations apply to Amazon Cognito identity pools that assume <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies-cross-account-resource-access.html">cross-account IAM roles</a>. The trust policies of these roles must accept the
    <code>cognito-identity.amazonaws.com</code> service principal and must contain the
    <code>cognito-identity.amazonaws.com:aud</code> condition key to restrict role
  assumption to users from your intended identity pools. A policy that trusts Amazon Cognito
  identity pools without this condition creates a risk that a user from an unintended
  identity pool can assume the role. For more information, see <a href="https://docs.aws.amazon.com/cognito/latest/developerguide/iam-roles.html#trust-policies"> Trust policies for IAM roles in Basic (Classic) authentication </a> in the <i>Amazon Cognito Developer Guide</i>.</p>

It's foreseeable that the `OktaOidcFederation` construct may produce multiple AWS Roles. In this case each role should be `CfnOutput` with a descriptive keyword as `key` and the **roleArn** in the `value` field. These roles are therefore saved to `stackOutputs.json` and may be consumed by other constructs. See `awsCredentialsLambda.ts` as an example.

In the lambda handler `awsCredentialsLambda/index.ts` the Role selection logic is implemented inside `getWebIdRole()` function.

## oktaCallbackLambda.

  This AWS Lambda executes some code but it also sends some as part of the returned web-page to be run in the browser. To achieve this the following steps were taken:
- `iifeFetchJwks.js` script implements the client (browser) side functionality.
- It's a regular `.js` file that doesn't need to be built. Though compilation/build is fairly foreseeable for complex scenarios.
- It is copied into the lambda bundle by `OktaCallbackLambda` that has `afterBundling` command hook.
- `afterBundling` is executed after the bundling process is complete but before the lambda is zipped up.
- From the lambda perspective the `.js` code is just a text file on lambda filesystem and can now be read by the handler, i.e. using `readFileSync`, see the handler code.
- The `iifeFetchJwks.js` content is included verbatim between the `html` \<script\>\<\/script\> tags.
- Variable `var oktaDomain = '${oktaDomain}';` in the lambda **HTML** section turns into a regular assignment in the browser: `var oktaDomain = 'dev-123456789.okta.com';`.
- It's important to properly "stringify" this type of assignments. Must use `JSON.stringify` and `JSON.parse` for arrays and objects.
- It's worth mentioning that some `client-side` tasks can be asynchronous and therefore may not finish before the web page fully renders and redirects.
- In order to adapt to this scenario the redirect is implemented inside the `then` clause of `iifeFetchJwks`: 
```
    .then((res)=>{
      // HTTP redirect:
      window.location.replace("/okta/authorize");
    })
```
- It's possible to do the OIDC authorization `fetch` in the browser too. It will probably save some lambda run-time \$. But I want to keep it simple here so it is what it is.
- Though if implemented, and I repeat the above mentioned notion here, all **async** tasks need to be chained up in a sequence of `.then()`. Even second fetch should look like `.then(res=>fetch(url))`. This is syntactically correct as the fetch API returns Promise.

## CORS.

It may not be such an obvious thing but when accessing AWS S3 whom the web browser via the **saws-sdk/client-s3** library the browser will still subject requests to CORS rules:
  - Preflight, OPTIONS with strict-origin-when-cross-origin header.
  - Response: access-control-allow-origin: * or whatever your CloudFront returns.
  - If you forget there will be very obvious message in the browser console.
  - Here's how to fix it in the CDK construct/stack:
  ```
      const assetBucket = new Bucket(this, `${props?.constructIdPrefix}AssetBucket`, {
...
      cors:[
        {
          allowedMethods: [HttpMethods.GET,], // Adjust as needed
          allowedOrigins: ['*'],    // Adjust to your specific origins
          allowedHeaders: ['*'],    // Adjust as needed
        },
      ]
    })
  ``` 
    - Probably some other AWS resources will require setting CORS too.
    